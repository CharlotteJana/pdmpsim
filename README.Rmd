---
title: Package pdmpsim
output:
  github_document:
    toc: true
    toc_depth: 2
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
library(pdmpsim)
```

# Introduction

The goal of pdmpsim is to simulate [piecewise deterministic 
markov processes](https://www.researchgate.net/publication/316281383_Piecewise-deterministic_Markov_processes_A_general_class_of_non-diffusion_stochastic_models_and_Discussion) (PDMPs) within R and to provide methods
for analysing the simulation results.  

It is possible to

* simulate PDMPs
* store multiple simulations in a convenient way
* calculate some statistics on them
* plot the results (there are different plot methods available)
* compute the generator numerically

The PDMPs can have multiple discrete and continous variables.
They are not allowed to have boundaries or a varying number of continous 
variables (the number should be independent of the state of the 
discrete variable).

You can install `pdmpsim` from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("CharlotteJana/pdmpsim")
```

# A simple example

This is a simple example modelling gene expression with positive feedback:

```{r}
examplePdmp <- new("pdmpModel",
                  descr = "Gene regulation with positive feedback",
                  parms = list(b = 0.5, a0 = 1, a1 = 3, k10 = 1, k01 = 0.5), 
                  init = c(f = 1, d = 1),
                  discStates = list(d = 0:1),
                  dynfunc = function(t, x, parms) {
                    df <- with(as.list(c(x, parms)), {
                      switch(d+1, a0 - b*f, a1 - b*f)
                    })
                    return(c(df, 0))
                  }, 
                  ratefunc = function(t, x, parms) {
                    return(with(as.list(c(x, parms)), switch(d + 1, k01*f, k10)))
                  }, 
                  jumpfunc = function(t, x, parms, jtype) {
                    c(x[1], 1 - x[2])
                  }, 
                  times = c(from = 0, to = 100, by = 0.1), 
                  solver = "lsodar")
```

Perform one simulation and plot the result:
```{r}
examplePDMP <- sim(examplePDMP)
plot(examplePDMP)
```

# Multiple simulations

Package `pdmpsim` provides two similar methods to perform and store a large number of different simulations of one PDMP. 

Function `multSim` returns an S3-object of class 
`multSim` which contains a list of simulation results, a list of time values declaring
the time needed for the corresponding simulation, the model that was used for simulation and a vector of numeric numbers. This vector is named `seeds`, its elements are used as argument to function `sim` and control the stochastic part of the model, making the simulation results reproducable. The vector `seeds` and the PDMP model are the only arguments needed for function `multSim`.

```{r, eval = FALSE}
simulations <- multSim(examplePDMP, seeds = 1:300)
```

The second function available to store multiple simulations is called `multSimCsv`. It is only useful if the memory used by all simulations exceeds the working memory. In this case, it is not possible to store all simulations in one object. They are stored in multiple csv files instead.

# Plot methods

There are several functions available to plot the simulations stored as `multSim`.

## Plot single simulations

```{r, eval = FALSE}
plotSeeds(simulations, seeds = c(1, 250))
```

![](https://raw.githubusercontent.com/CharlotteJana/pdmppoly/charlotte/man/figures/README-plotSeeds.png)

## Heatmap over all simulations

```{r, eval = FALSE}
plot(simulations, discPlot = "line")
```

![](https://raw.githubusercontent.com/CharlotteJana/pdmppoly/charlotte/man/figures/README-heatmap.png)

## Boxplot and violin plot

```{r, eval = FALSE}
plotTimes(simulations, plottype = "violin", times = c(3, 50, 100))
```

![](https://raw.githubusercontent.com/CharlotteJana/pdmppoly/charlotte/man/figures/README-violins.png)

```{r, eval = FALSE}
plotTimes(simulations, vars = "f", times = c(20, 50, 80, 100), nolo = 3)
```

![](https://raw.githubusercontent.com/CharlotteJana/pdmppoly/charlotte/man/figures/README-boxplot.png)

## Density plot and histogram

```{r, eval = FALSE}
density(simulations, t = c(3, 50, 80, 100))
```

![](https://raw.githubusercontent.com/CharlotteJana/pdmppoly/charlotte/man/figures/README-density.png)

## Calculate and plot statistics

Calculate minimum, mean and maximum and plot them:
```{r}
summarise_at(simulations, .vars = "f", .funs = c("sd", "mean", "sum"))
plotStats(simulations, vars = "f", funs = c("min", "mean", "median", "max"))
```

![](https://raw.githubusercontent.com/CharlotteJana/pdmppoly/charlotte/man/figures/README-statistics.png)

# A more sophisticated example

The PDMP presented in this paragraph models a gene regulation mechanism with toggle switch
between two genes. We consider two genes $A$ and $B$, and the concentration of their gene products, $f_A$ and $f_B$. A product of gene $A$ can block the transcription of gene $B$ and therefore affects the concentration $f_B$. Conversely, a product of gene $B$ can block gene $A$.

![](https://raw.githubusercontent.com/CharlotteJana/pdmppoly/charlotte/man/figures/README-toggleSwitch.png)

The PDMP contains six different constant parameters: $k_{01}, k_{10}, a_A, a_B, b_A$ and $b_B$. The formulation as `pdmpModel` object ist as follows:

```{r}

toggleSwitch <- pdmpModel(
    descr = "Toggle switch with two promotors",
    parms = list(bA = 0.5, bB = 0.5, aA = 2, aB = 4, k01 = 0.5, k10 = 2),
    init = c(fA = 0.5, fB = 0.5, dA = 1.0, dB = 1.0),
    discStates = list(dA = c(0, 1), dB = c(0, 1)),
    times = c(from = 0, to = 100, by = 0.01),
    dynfunc = function(t, x, parms) {
       df <- with(as.list(c(x, parms)), c(-bA*fA + aA*dA, -bB*fB + aB*dB))
       return(c(df, 0, 0))
    },
    ratefunc = function(t, x, parms) {
       return(with(as.list(c(x, parms)), c(switch(dB+1, k01, k10*fA),
                                           switch(dA+1, k01, k10*fB))))
    },
    jumpfunc = function(t, x, parms, jtype){
       return(with(as.list(c(x, parms)), c(fA, fB, switch(jtype,
                                                          c(dA, 1-dB),
                                                          c(1-dA, dB)))))
    })
```

The model is included in package `pdmpsim` as an example, a detailed description of the different slots can be loaded with `?toggleSwitch`.

```{r, warning=FALSE, message=FALSE}
plot(sim(toggleSwitch), ggplot = TRUE) + 
  ggplot2::scale_color_manual(values = c("orange", "palegreen3")) # change color
```

# License

Some classes introduced in package `pdmpsim` are based on code from package [simecol](http://simecol.r-forge.r-project.org/). Both packages are free open source software licensed under the [GNU Public License](https://www.gnu.org/licenses/#GPL) (GPL 2.0 or above). The software is provided as is and comes WITHOUT WARRANTY.